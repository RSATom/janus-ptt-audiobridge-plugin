#pragma once

#include <cstdint>

#include <glib.h>

#include <opus/opus.h>

extern "C" {
#include "janus/refcount.h"
}


namespace ptt_audioroom
{

struct ptt_room {
	janus_refcount ref;			/* Reference counter for this room */
	gchar *room_id_str;			/* Unique room ID (when using strings) */
	gchar *room_name;			/* Room description */
	gchar *room_secret;			/* Secret needed to manipulate (e.g., destroy) this room */
	gchar *room_pin;			/* Password needed to join this room, if any */
	uint32_t room_ssrc;			/* SSRC we'll use for packets generated by the mixer */
	gboolean is_private;		/* Whether this room is 'private' (as in hidden) or not */
	gboolean audiolevel_ext;	/* Whether the ssrc-audio-level extension must be negotiated or not for new joins */
	gboolean audiolevel_event;	/* Whether to emit event to other users about audiolevel */
	uint default_prebuffering;	/* Number of packets to buffer before decoding each participant */
	int audio_active_packets;	/* Amount of packets with audio level for checkup */
	int audio_level_average;	/* Average audio level */
	gboolean mjrs;				/* Whether all participants in the room should be individually recorded to mjr files or not */
	gchar *mjrs_dir;			/* Folder to save the mjrs file to */
	gboolean destroy;			/* Value to flag the room for destruction */
	GHashTable *participants;	/* Map of participants */
	struct room_participant* unmutedParticipant;
	gboolean check_tokens;		/* Whether to check tokens when participants join (see below) */
	GHashTable *allowed;		/* Map of participants (as tokens) allowed to join */
	GThread *thread;			/* Mixer thread for this room */
	gint destroyed;	/* Whether this room has been destroyed */
	janus_mutex mutex;			/* Mutex to lock this room instance */
	/* RTP forwarders for this room's mix */
	GHashTable *rtp_forwarders;	/* RTP forwarders list (as a hashmap) */
	janus_mutex rtp_mutex;		/* Mutex to lock the RTP forwarders list */
	int rtp_udp_sock;			/* UDP socket to use to forward RTP packets */
};

void* room_sender_thread(void* data);

int create_udp_socket_if_needed(ptt_room *audiobridge);

void ptt_room_destroy(ptt_room *audiobridge);
void ptt_room_free(const janus_refcount *audiobridge_ref);

}
